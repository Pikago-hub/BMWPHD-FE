{
  "version": 3,
  "sources": ["../../vue-class-component/dist/vue-class-component.esm-bundler.js", "../../vuex-pathify/dist/vuex-pathify.esm.js"],
  "sourcesContent": ["/**\n  * vue-class-component v8.0.0-rc.1\n  * (c) 2015-present Evan You\n  * @license MIT\n  */\nimport { ref, proxyRefs } from 'vue';\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction defineGetter(obj, key, getter) {\n  Object.defineProperty(obj, key, {\n    get: getter,\n    enumerable: false,\n    configurable: true\n  });\n}\n\nfunction defineProxy(proxy, key, target) {\n  Object.defineProperty(proxy, key, {\n    get: function get() {\n      return target[key].value;\n    },\n    set: function set(value) {\n      target[key].value = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n}\n\nfunction getSuper(Ctor) {\n  var superProto = Object.getPrototypeOf(Ctor.prototype);\n\n  if (!superProto) {\n    return undefined;\n  }\n\n  return superProto.constructor;\n}\n\nfunction getOwn(value, key) {\n  return value.hasOwnProperty(key) ? value[key] : undefined;\n}\n\nvar VueImpl = /*#__PURE__*/function () {\n  function VueImpl(props, ctx) {\n    var _this = this;\n\n    _classCallCheck(this, VueImpl);\n\n    defineGetter(this, '$props', function () {\n      return props;\n    });\n    defineGetter(this, '$attrs', function () {\n      return ctx.attrs;\n    });\n    defineGetter(this, '$slots', function () {\n      return ctx.slots;\n    });\n    defineGetter(this, '$emit', function () {\n      return ctx.emit;\n    });\n    Object.keys(props).forEach(function (key) {\n      Object.defineProperty(_this, key, {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: props[key]\n      });\n    });\n  }\n\n  _createClass(VueImpl, null, [{\n    key: \"registerHooks\",\n    value: function registerHooks(keys) {\n      var _this$__h;\n\n      (_this$__h = this.__h).push.apply(_this$__h, _toConsumableArray(keys));\n    }\n  }, {\n    key: \"with\",\n    value: function _with(Props) {\n      var propsMeta = new Props();\n      var props = {};\n      Object.keys(propsMeta).forEach(function (key) {\n        var meta = propsMeta[key];\n        props[key] = meta !== null && meta !== void 0 ? meta : null;\n      });\n\n      var PropsMixin = /*#__PURE__*/function (_this2) {\n        _inherits(PropsMixin, _this2);\n\n        var _super = _createSuper(PropsMixin);\n\n        function PropsMixin() {\n          _classCallCheck(this, PropsMixin);\n\n          return _super.apply(this, arguments);\n        }\n\n        return PropsMixin;\n      }(this);\n\n      PropsMixin.__b = {\n        props: props\n      };\n      return PropsMixin;\n    }\n  }, {\n    key: \"__vccOpts\",\n    get: function get() {\n      // Early return if `this` is base class as it does not have any options\n      if (this === Vue) {\n        return {};\n      }\n\n      var Ctor = this;\n      var cache = getOwn(Ctor, '__c');\n\n      if (cache) {\n        return cache;\n      } // If the options are provided via decorator use it as a base\n\n\n      var options = _objectSpread2({}, getOwn(Ctor, '__o'));\n\n      Ctor.__c = options; // Handle super class options\n\n      var Super = getSuper(Ctor);\n\n      if (Super) {\n        options[\"extends\"] = Super.__vccOpts;\n      } // Inject base options as a mixin\n\n\n      var base = getOwn(Ctor, '__b');\n\n      if (base) {\n        options.mixins = options.mixins || [];\n        options.mixins.unshift(base);\n      }\n\n      options.methods = _objectSpread2({}, options.methods);\n      options.computed = _objectSpread2({}, options.computed);\n      var proto = Ctor.prototype;\n      Object.getOwnPropertyNames(proto).forEach(function (key) {\n        if (key === 'constructor') {\n          return;\n        } // hooks\n\n\n        if (Ctor.__h.indexOf(key) > -1) {\n          options[key] = proto[key];\n          return;\n        }\n\n        var descriptor = Object.getOwnPropertyDescriptor(proto, key); // methods\n\n        if (typeof descriptor.value === 'function') {\n          options.methods[key] = descriptor.value;\n          return;\n        } // computed properties\n\n\n        if (descriptor.get || descriptor.set) {\n          options.computed[key] = {\n            get: descriptor.get,\n            set: descriptor.set\n          };\n          return;\n        }\n      });\n\n      options.setup = function (props, ctx) {\n        var _promise;\n\n        var data = new Ctor(props, ctx);\n        var dataKeys = Object.keys(data);\n        var plainData = {};\n        var promise = null; // Initialize reactive data and convert constructor `this` to a proxy\n\n        dataKeys.forEach(function (key) {\n          // Skip if the value is undefined not to make it reactive.\n          // If the value has `__s`, it's a value from `setup` helper, proceed it later.\n          if (data[key] === undefined || data[key] && data[key].__s) {\n            return;\n          }\n\n          plainData[key] = ref(data[key]);\n          defineProxy(data, key, plainData);\n        }); // Invoke composition functions\n\n        dataKeys.forEach(function (key) {\n          if (data[key] && data[key].__s) {\n            var setupState = data[key].__s();\n\n            if (setupState instanceof Promise) {\n              if (!promise) {\n                promise = Promise.resolve(plainData);\n              }\n\n              promise = promise.then(function () {\n                return setupState.then(function (value) {\n                  plainData[key] = proxyRefs(value);\n                  return plainData;\n                });\n              });\n            } else {\n              plainData[key] = proxyRefs(setupState);\n            }\n          }\n        });\n        return (_promise = promise) !== null && _promise !== void 0 ? _promise : plainData;\n      };\n\n      var decorators = getOwn(Ctor, '__d');\n\n      if (decorators) {\n        decorators.forEach(function (fn) {\n          return fn(options);\n        });\n      } // from Vue Loader\n\n\n      var injections = ['render', 'ssrRender', '__file', '__cssModules', '__scopeId', '__hmrId'];\n      injections.forEach(function (key) {\n        if (Ctor[key]) {\n          options[key] = Ctor[key];\n        }\n      });\n      return options;\n    }\n  }]);\n\n  return VueImpl;\n}();\n\nVueImpl.__h = ['data', 'beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUnmount', 'unmounted', 'beforeUpdate', 'updated', 'activated', 'deactivated', 'render', 'errorCaptured', 'serverPrefetch'];\nvar Vue = VueImpl;\n\nfunction Options(options) {\n  return function (Component) {\n    Component.__o = options;\n    return Component;\n  };\n}\nfunction createDecorator(factory) {\n  return function (target, key, index) {\n    var Ctor = typeof target === 'function' ? target : target.constructor;\n\n    if (!Ctor.__d) {\n      Ctor.__d = [];\n    }\n\n    if (typeof index !== 'number') {\n      index = undefined;\n    }\n\n    Ctor.__d.push(function (options) {\n      return factory(options, key, index);\n    });\n  };\n}\nfunction mixins() {\n  for (var _len = arguments.length, Ctors = new Array(_len), _key = 0; _key < _len; _key++) {\n    Ctors[_key] = arguments[_key];\n  }\n\n  var _a;\n\n  return _a = /*#__PURE__*/function (_Vue) {\n    _inherits(MixedVue, _Vue);\n\n    var _super = _createSuper(MixedVue);\n\n    function MixedVue() {\n      var _this;\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      _classCallCheck(this, MixedVue);\n\n      _this = _super.call.apply(_super, [this].concat(args));\n      Ctors.forEach(function (Ctor) {\n        var data = _construct(Ctor, args);\n\n        Object.keys(data).forEach(function (key) {\n          _this[key] = data[key];\n        });\n      });\n      return _this;\n    }\n\n    return MixedVue;\n  }(Vue), _a.__b = {\n    mixins: Ctors.map(function (Ctor) {\n      return Ctor.__vccOpts;\n    })\n  }, _a;\n}\nfunction setup(setupFn) {\n  // Hack to delay the invocation of setup function.\n  // Will be called after dealing with class properties.\n  return {\n    __s: setupFn\n  };\n}\n\n// Actual implementation\nfunction prop(options) {\n  return options;\n}\n\nexport { Options, Vue, createDecorator, mixins, prop, setup };\n", "/**\n * Bundle of: vuex-pathify\n * Generated: 2022-03-18\n * Version: 3.0.0-beta\n */\n\nimport { computed } from 'vue';\nimport { createDecorator } from 'vue-class-component';\n\n/**\n * Tests whether a passed value is an Object\n *\n * @param   {*}       value   The value to be assessed\n * @returns {boolean}         Whether the value is a true Object\n */\nfunction isPlainObject (value) {\n  return isObject(value) && !Array.isArray(value)\n}\n\n/**\n * Tests whether a passed value is an Object or Array\n *\n * @param   {*}       value   The value to be assessed\n * @returns {boolean}         Whether the value is an Object or Array\n */\nfunction isObject (value) {\n  return !!value && typeof value === 'object'\n}\n\n/**\n * Tests whether a string is numeric\n *\n * @param   {string|number}   value   The value to be assessed\n * @returns {boolean}\n */\nfunction isNumeric (value) {\n  return typeof value === 'number' || /^\\d+$/.test(value)\n}\n\n/**\n * Tests whether a passed value is an Object and has the specified key\n *\n * @param   {Object}   obj    The source object\n * @param   {string}   key    The key to check that exists\n * @returns {boolean}         Whether the predicate is satisfied\n */\nfunction hasKey (obj, key) {\n  return isObject(obj) && key in obj\n}\n\n/**\n * Gets an array of keys from a value\n *\n * The function handles various types:\n *\n * - string - match all words\n * - object - return keys\n * - array  - return a string array of its values\n *\n * @param   {*}       value   The value to get keys from\n * @returns {Array}\n */\nfunction getKeys (value) {\n  return !value\n    ? []\n    : Array.isArray(value)\n      ? value.map(function (key) { return String(key); })\n      : typeof value === 'object'\n        ? Object.keys(value)\n        : typeof value === 'string'\n          ? value.match(/[-$\\w]+/g) || []\n          : []\n}\n\n/**\n * Gets a value from an object, based on a path to the property\n *\n * @param   {Object}                obj     The Object to get the value from\n * @param   {string|Array|Object}  [path]   The optional path to a sub-property\n * @returns {*}\n */\nfunction getValue (obj, path) {\n  var value = obj;\n  var keys = getKeys(path);\n\n  keys.every(function (key) {\n    var valid = isObject(value) && value.hasOwnProperty(key);\n    value = valid ? value[key] : void 0;\n    return valid\n  });\n  return value\n}\n\n/**\n * Sets a value on an object, based on a path to the property\n *\n * @param   {Object}                obj       The Object to set the value on\n * @param   {string|Array|Object}   path      The path to a sub-property\n * @param   {*}                     value     The value to set\n * @param   {boolean}              [create]   Optional flag to create sub-properties; defaults to false\n * @returns {Boolean}                         True or false, depending if value was set\n */\nfunction setValue (obj, path, value, create) {\n  if ( create === void 0 ) create = false;\n\n  var keys = getKeys(path);\n  return keys.reduce(function (obj, key, index) {\n    // early return if no object\n    if (!obj) {\n      return false\n    }\n\n    // convert key to index if obj is an array and key is numeric\n    if (Array.isArray(obj) && isNumeric(key)) {\n      key = parseInt(key);\n    }\n\n    // if we're at the end of the path, set the value\n    if (index === keys.length - 1) {\n      obj[key] = value;\n      return true\n    }\n\n    // if the target property doesn't exist...\n    else if (!isObject(obj[key]) || !(key in obj)) {\n      // ...create one, or cancel\n      if (create) {\n        // create object or array, depending on next key\n        obj[key] = isNumeric(keys[index + 1])\n          ? []\n          : {};\n      }\n      else {\n        return false\n      }\n    }\n\n    // if we get here, return the target property\n    return obj[key]\n  }, obj)\n}\n\n/**\n * Checks an object has a property, based on a path to the property\n *\n * @param   {Object}                obj     The Object to check the value on\n * @param   {string|Array|Object}   path    The path to a sub-property\n * @returns {boolean}                       Boolean true or false\n */\nfunction hasValue (obj, path) {\n  var keys = getKeys(path);\n  if (isObject(obj)) {\n    while (keys.length) {\n      var key = keys.shift();\n      if (hasKey(obj, key)) {\n        obj = obj[key];\n      }\n      else {\n        return false\n      }\n    }\n    return true\n  }\n  return false\n}\n\nfunction clone (obj) {\n  return JSON.parse(JSON.stringify(obj))\n}\n\nvar options = {\n  mapping: 'standard',  // map states to store members using the \"standard\" scheme\n  strict: true,         // throw an error if the store member cannot be found\n  cache: true,          // cache generated functions for faster re-use\n  deep: 1,              // allow sub-property access, but not creation\n};\n\nvar formatters = {\n  camel: function () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    return args.shift() + args\n      .map(function (text) { return text.replace(/\\w/, function (c) { return c.toUpperCase(); }); })\n      .join('')\n  },\n\n  snake: function () {\n    var ref;\n\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n    return (ref = this)\n      .camel.apply(ref, args)\n      .replace(/([a-z])([A-Z])/g, function (match, a, b) { return a + '_' + b; })\n      .toLowerCase()\n  },\n\n  const: function () {\n    var ref;\n\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n    return (ref = this)\n      .snake.apply(ref, args)\n      .toUpperCase()\n  }\n};\n\n/**\n * Map of store members\n */\nvar members = {\n  state: 'state',\n  getters: 'getters',\n  actions: '_actions',\n  mutations: '_mutations',\n};\n\n/**\n * Map of default resolver functions\n */\nvar resolvers = {\n\n  /**\n   * Standard name mapping function\n   *\n   * Adheres to seemingly the most common Vuex naming pattern\n   *\n   * @param   {string}  type          The member type, i.e state, getters, mutations, or actions\n   * @param   {string}  name          The name of the property being targeted, i.e. value\n   * @param   {object}  formatters    A formatters object with common format functions, camel, snake, const\n   * @returns {string}\n   */\n  standard: function standard (type, name, formatters$$1) {\n    switch (type) {\n      case 'mutations':\n        return formatters$$1.const('set', name) // SET_BAR\n      case 'actions':\n        return formatters$$1.camel('set', name) // setBar\n    }\n    return name // bar\n  },\n\n  /**\n   * Simple name mapping function\n   */\n  simple: function simple (type, name, formatters$$1) {\n    if (type === 'actions') {\n      return formatters$$1.camel('set', name) // setBar\n    }\n    return name // bar\n  },\n\n};\n\n/**\n * Configured resolver\n */\nvar resolver;\n\n/**\n * Internal function to resolve member name using configured mapping function\n *\n * @param   {string}  type  The member type, i.e. actions\n * @param   {string}  name  The supplied path member id, i.e. value\n * @returns {string}        The resolved member name, i.e. SET_VALUE\n */\nfunction resolveName (type, name) {\n  // bypass resolver\n  if (name.match(/!$/)) {\n    return name.substr(0, name.length - 1)\n  }\n\n  // configured resolver\n  var fn = resolver;\n\n  // unconfigured resolver! (runs once)\n  if (!fn) {\n    if (typeof options.mapping === 'function') {\n      fn = options.mapping;\n    }\n    else {\n      fn = resolvers[options.mapping];\n      if (!fn) {\n        throw new Error((\"[Vuex Pathify] Unknown mapping '\" + (options.mapping) + \"' in options\\n    - Choose one of '\" + (Object.keys(resolvers).join(\"', '\")) + \"'\\n    - Or, supply a custom function\\n\"))\n      }\n    }\n\n    resolver = fn;\n  }\n\n  // resolve!\n  return resolver(type, name, formatters)\n}\n\n/**\n * Creates a resolver object that caches properties and can resolve store member properties\n *\n * @param   {object}  store     The Vuex store instance\n * @param   {string}  path      A pathify path to the store target, i.e. 'foo/bar@a.b.c'\n * @returns {object}\n */\nfunction resolve (store, path) {\n  // state\n  var absPath = path.replace(/[/@!]+/g, '.');\n\n  // paths\n  var ref = path.split('@');\n  var statePath = ref[0];\n  var objPath = ref[1];\n\n  // parent\n  var modPath, trgName;\n  if (statePath.indexOf('/') > -1) {\n    var keys = statePath.split('/');\n    trgName = keys.pop();\n    modPath = keys.join('/');\n  }\n  else {\n    trgName = statePath;\n  }\n\n  // throw error if module does not exist\n  if (modPath && !store._modulesNamespaceMap[modPath + '/']) {\n    throw new Error((\"[Vuex Pathify] Unknown module '\" + modPath + \"' via path '\" + path + \"'\"))\n  }\n\n  // resolve targets\n  return {\n    absPath: absPath,\n    module: modPath,\n    target: statePath,\n    name: trgName.replace('!', ''),\n    isDynamic: path.indexOf(':') > -1,\n\n    /**\n     * Returns properties about the targeted member\n     *\n     * @param   {string}  type  The member type, i.e state, getters, mutations, or actions\n     * @returns {{exists: boolean, member: object, type: string, path: string}}\n     */\n    get: function (type) {\n      // targeted member, i.e. store._getters\n      var member = store[members[type]];\n\n      // resolved target name, i.e. SET_VALUE\n      var resName = resolveName(type, trgName);\n\n      // target path, i.e. store._getters['module/SET_VALUE']\n      var trgPath = modPath\n        ? modPath + '/' + resName\n        : resName;\n\n      // return values\n      return {\n        exists: type === 'state'\n          ? hasValue(member, trgPath)\n          : member\n            ? trgPath in member\n            : false,\n        member: member,\n        trgPath: trgPath,\n        trgName: resName,\n        objPath: objPath,\n      }\n    }\n  }\n}\n\n/**\n * Error generation function for accessors\n */\nfunction getError (path, resolver, aName, a, bName, b) {\n  var error = \"[Vuex Pathify] Unable to map path '\" + path + \"':\";\n  if (path.indexOf('!') > -1) {\n    error += \"\\n    - Did not find \" + aName + \" or \" + bName + \" named '\" + (resolver.name) + \"' on \" + (resolver.module ? (\"module '\" + (resolver.module) + \"'\") : 'root store');\n  }\n  else {\n    var aText = a\n      ? (aName + \" '\" + (a.trgName) + \"' or \")\n      : '';\n    var bText = bName + \" '\" + (b.trgName) + \"'\";\n    error += \"\\n    - Did not find \" + aText + bText + \" on \" + (resolver.module ? (\"module '\" + (resolver.module) + \"'\") : 'store') + \"\\n    - Use direct syntax '\" + (resolver.target.replace(/(@|$)/, '!$1')) + \"' (if member exists) to target directly\";\n  }\n  return error\n}\n\n/**\n * Handles passing and setting of sub-property values\n */\nvar Payload = function Payload (expr, path, value) {\n  this.expr = expr;\n  this.path = path;\n  this.value = value;\n};\n\n/**\n * Set sub-property on target\n * @param target\n */\nPayload.prototype.update = function update (target) {\n  if (!options.deep) {\n    console.error((\"[Vuex Pathify] Unable to access sub-property for path '\" + (this.expr) + \"':\\n    - Set option 'deep' to 1 to allow it\"));\n    return target\n  }\n\n  var success = setValue(target, this.path, this.value, options.deep > 1);\n\n  // unable to set sub-property\n  if (!success && process.env.NODE_ENV !== 'production') {\n    console.error((\"[Vuex Pathify] Unable to create sub-property for path '\" + (this.expr) + \"':\\n    - Set option 'deep' to 2 to allow it\"));\n    return target\n  }\n\n  // set sub-property\n  return Array.isArray(target)\n    ? [].concat(target)\n    : Object.assign({}, target)\n};\n\n/**\n * Test if value is a serialized Payload\n *\n * @see https://github.com/davestewart/vuex-pathify/pull/125\n */\nPayload.isSerialized = function (value) {\n  return isPlainObject(value)\n    && 'expr' in value\n    && 'path' in value\n    && 'value' in value\n};\n\n/**\n * Creates a setter function for the store, automatically targeting actions or mutations\n *\n * Also supports setting of sub-properties as part of the path\n *\n * @see documentation for more detail\n *\n * @param   {Object}  store   The store object\n * @param   {string}  path    The path to the target node\n * @returns {*|Promise}       The return value from the commit() or dispatch()\n */\nfunction makeSetter (store, path) {\n  var resolver = resolve(store, path);\n\n  var action = resolver.get('actions');\n  if (action.exists) {\n    return function (value) {\n      var payload = action.objPath\n        ? new Payload(path, action.objPath, value)\n        : value;\n      return store.dispatch(action.trgPath, payload)\n    }\n  }\n\n  var mutation = resolver.get('mutations');\n  if (mutation.exists || resolver.isDynamic) {\n    return function (value) {\n      // rebuild mutation if using dynamic path\n      if (resolver.isDynamic) {\n        var interpolated = interpolate(path, this);\n        mutation = resolve(store, interpolated).get('mutations');\n      }\n      var payload = mutation.objPath\n        ? new Payload(path, mutation.objPath, value)\n        : value;\n      return store.commit(mutation.trgPath, payload)\n    }\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    console.error(getError(path, resolver, 'action', action, 'mutation', mutation));\n  }\n\n  return function (value) {}\n}\n\n/**\n * Creates a getter function for the store, automatically targeting getters or state\n *\n * Also supports returning of sub-properties as part of the path\n *\n * @see documentation for more detail\n *\n * @param   {Object}    store       The store object\n * @param   {string}    path        The path to the target node\n * @param   {boolean}  [stateOnly]  An optional flag to get from state only (used when syncing)\n * @returns {*|Function}            The state value or getter function\n */\nfunction makeGetter (store, path, stateOnly) {\n  var resolver = resolve(store, path);\n\n  // for sync, we don't want to read only from state\n  var getter;\n  if (!stateOnly) {\n    getter = resolver.get('getters');\n    if (getter.exists) {\n      return function () {\n        var value = getter.member[getter.trgPath];\n        return getter.objPath\n          ? getValueIfEnabled(path, value, getter.objPath)\n          : value\n      }\n    }\n  }\n\n  var state = resolver.get('state');\n  if (state.exists || resolver.isDynamic) {\n    return function () {\n      var absPath = resolver.isDynamic\n        ? interpolate(resolver.absPath, this)\n        : resolver.absPath;\n      return getValueIfEnabled(path, store.state, absPath)\n    }\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    console.error(getError(path, resolver, 'getter', getter, 'state', state));\n  }\n\n  return function () {}\n}\n\n/**\n * Utility function to get value from store, but only if options allow\n *\n * @param   {string}  expr    The full path expression\n * @param   {object}  source  The source object to get property from\n * @param   {string}  path    The full dot-path on the source object\n * @returns {*}\n */\nfunction getValueIfEnabled (expr, source, path) {\n  if (!options.deep && expr.indexOf('@') > -1) {\n    console.error((\"[Vuex Pathify] Unable to access sub-property for path '\" + expr + \"':\\n    - Set option 'deep' to 1 to allow it\"));\n    return\n  }\n  return getValue(source, path)\n}\n\n/**\n * Utility function to interpolate a string with properties\n * @param   {string}  path    The path containing interpolation :tokens\n * @param   {object}  scope   The scope containing properties to be used\n * @return  {string}\n */\nfunction interpolate (path, scope) {\n  return path.replace(/:(\\w+)/g, function replace (all, token) {\n    if (!(token in scope)) {\n      console.error((\"Error resolving dynamic store path: The property \\\"\" + token + \"\\\" does not exist on the scope\"), scope);\n    }\n    return scope[token]\n  })\n}\n\nvar vuex = {\n  /**\n   * THIS OBJECT IS REPLACED AT RUNTIME WITH THE ACTUAL VUEX STORE\n   */\n  store: {\n    state: null,\n\n    commit: function commit () {\n      if (process.env.NODE_ENV !== 'production') {\n        console.error('[Vuex Pathify] Plugin not initialized!');\n      }\n    },\n\n    dispatch: function dispatch () {\n      if (process.env.NODE_ENV !== 'production') {\n        console.error('[Vuex Pathify] Plugin not initialized!');\n      }\n    }\n  }\n};\n\nfunction getStore () {\n  return vuex.store\n}\n\nfunction setStore (store) {\n  // set store\n  vuex.store = store;\n\n  /**\n   * Set a property on the store, automatically using actions or mutations\n   *\n   * @param   {string}        path    The path to the store member\n   * @param   {*}             value   The value to set\n   * @returns {Promise|*}             Any return value from the action / commit\n   */\n  store.set = function (path, value) {\n    var setter = makeSetter(store, path);\n    if (typeof setter !== 'undefined') {\n      return setter(value)\n    }\n  };\n\n  /**\n   * Get a property from the store, automatically using getters or state\n   *\n   * @param   {string}        path    The path to the store member\n   * @param   {*}             args    Optional getter function parameters\n   * @returns {*|undefined}           The state value / getter value / getter function / or undefined\n   */\n  store.get = function (path) {\n    var args = [], len = arguments.length - 1;\n    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n    var getter = makeGetter(store, path);\n    if (typeof getter !== 'undefined') {\n      var value = getter();\n      return typeof value === 'function'\n        ? value.apply(void 0, args)\n        : value\n    }\n  };\n\n  /**\n   * Get a copy of a property from the store, automatically using actions or mutations\n   *\n   * @param   {string}        path    The path to the store member\n   * @param   {*}             args    Optional getter function parameters\n   * @returns {*|undefined}           The value, or undefined\n   */\n  store.copy = function (path) {\n    var args = [], len = arguments.length - 1;\n    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n    var value = store.get.apply(store, [ path ].concat( args ));\n    return isObject(value)\n      ? clone(value)\n      : value\n  };\n}\n\nfunction commit () {\n  var ref;\n\n  var args = [], len = arguments.length;\n  while ( len-- ) args[ len ] = arguments[ len ];\n  (ref = vuex.store).commit.apply(ref, args);\n}\n\nfunction dispatch () {\n  var ref;\n\n  var args = [], len = arguments.length;\n  while ( len-- ) args[ len ] = arguments[ len ];\n  return (ref = vuex.store).dispatch.apply(ref, args)\n}\n\n/**\n * Helper function to generate a mixin that registers module and computed properties on component creation\n *\n * @param   {string|Array}  path        The path to register the Vuex module on\n * @param   {object}        module      The module definition to register when the\n * @param   {function}      callback    A callback returning store members to be added to the component definition\n * @param   {object}       [options]    Optional Vuex module registration options\n * @returns {object}                    The mixin\n */\nfunction registerModule (path, module, callback, options) {\n  return {\n    beforeCreate: function beforeCreate () {\n      this.$store.registerModule(path, module, options);\n      var members = callback();\n      this.$options.computed = Object.assign(this.$options.computed || {}, members.computed || {});\n      this.$options.methods = Object.assign(this.$options.methods || {}, members.methods || {});\n    },\n\n    destroyed: function destroyed () {\n      this.$store.unregisterModule(path);\n    }\n  }\n}\n\nfunction resolve$1 (type) {\n  return resolveName(type, 'value')\n}\n\nfunction debug () {\n  console.log((\"\\n  [Vuex Pathify] Options:\\n\\n  Mapping (\" + (typeof options.mapping === 'function' ? 'custom' : options.mapping) + \")\\n-------------------------------\\n  path       : value\\n  state      : \" + (resolve$1('state')) + \"\\n  getters    : \" + (resolve$1('getters')) + \"\\n  actions    : \" + (resolve$1('actions')) + \"\\n  mutations  : \" + (resolve$1('mutations')) + \"\\n\\n  Settings\\n-------------------------------\\n  strict     : \" + (options.strict) + \"\\n  cache      : \" + (options.cache) + \"\\n  deep       : \" + (options.deep) + \"\\n\\n\"));\n}\n\n// plugin\n\n/**\n * Store plugin which updates the store object with set() and get() methods\n *\n * @param {Object} store  The store object\n */\nfunction plugin (store) {\n  setStore(store);\n}\n\nvar pathify = {\n  options: options,\n  plugin: plugin,\n  debug: debug,\n};\n\n/**\n * Utility function to grab keys for state\n *\n * @param   {Object|Function|Array|String}   state   State object, state function, array or string of key names\n * @returns {Array}\n */\nfunction getStateKeys (state) {\n  return getKeys(typeof state === 'function' ? state() : state)\n}\n\n/**\n * Helper function to mass-create default getter functions for an existing state object\n *\n * Note that you don't need to create top-level getter functions if using $store.get(...)\n *\n * @param   {Object|Function|Array|String}   state   State object, state function, array or string of key names\n */\nfunction makeGetters (state) {\n  return getStateKeys(state)\n    .reduce(function (obj, key) {\n      var getter = resolveName('getters', key);\n      obj[getter] = function (state) {\n        return state[key]\n      };\n      return obj\n    }, {})\n}\n\n/**\n * Helper function to mass-create default mutation functions for an existing state object\n *\n * @param   {Object|Function|Array|String}   state   State object, state function, array or string of key names\n */\nfunction makeMutations (state) {\n  return getStateKeys(state)\n    .reduce(function (obj, key) {\n      var mutation = resolveName('mutations', key);\n      obj[mutation] = function (state, value) {\n        if (value instanceof Payload) {\n          value = value.update(state[key]);\n        }\n        else if (Payload.isSerialized(value)) {\n          value = Payload.prototype.update.call(value, state[key]);\n        }\n        state[key] = value;\n      };\n      return obj\n    }, {})\n}\n\n/**\n * Helper function to mass-create default actions functions for an existing state object\n *\n * @param   {Object|Function|Array|String}   state   State object, state function, array or string of key names\n */\nfunction makeActions (state) {\n  return getStateKeys(state)\n    .reduce(function (obj, key) {\n      var action = resolveName('actions', key);\n      var mutation = resolveName('mutations', key);\n      obj[action] = function (ref, value) {\n        var commit = ref.commit;\n\n        commit(mutation, value);\n      };\n      return obj\n    }, {})\n}\n\nvar store = {\n  getters: makeGetters,\n  mutations: makeMutations,\n  actions: makeActions,\n};\n\n// -------------------------------------------------------------------------------------------------------------------\n// external\n// -------------------------------------------------------------------------------------------------------------------\n\n/**\n * Utility function to expand wildcard path for get()\n *\n * @param   {string}        path        wildcard path\n * @param   {object}        state       state hash\n * @param   {object}        getters     getters hash\n * @returns {array|string}\n */\nfunction expandGet (path, state, getters) {\n  if (!init(path, state)) {\n    return ''\n  }\n  return resolveStates(path, state).concat( resolveHandlers(path, getters) )\n}\n\n/**\n * Utility function to expand wildcard path for sync()\n *\n * @param   {string}        path        wildcard path\n * @param   {object}        state       state hash\n * @returns {array|string}\n */\nfunction expandSync (path, state) {\n  if (!init(path, state)) {\n    return ''\n  }\n  return resolveStates(path, state)\n}\n\n/**\n * Utility function to expand wildcard path for actions()\n *\n * @param   {string}        path        wildcard path\n * @param   {object}        actions     actions hash\n * @returns {array|string}\n */\nfunction expandCall (path, actions) {\n  if (!init(path, actions)) {\n    return ''\n  }\n  return resolveHandlers(path, actions)\n}\n\n// -------------------------------------------------------------------------------------------------------------------\n// internal\n// -------------------------------------------------------------------------------------------------------------------\n\n/**\n * Helper function to resolve state properties from a wildcard path\n *\n * Note: this function traverses into the state object and any properties / sub-properties\n *\n * @param   {string}    path    A path with a wildcard at the end\n * @param   {object}    state   A state object on which to look up the sub-properties\n * @returns {string[]}          An array of paths\n */\nfunction resolveStates (path, state) {\n  // grab segments\n  var last = path.match(/([^/@\\.]+)$/)[1];\n  var main = path.substring(0, path.length - last.length);\n  var keys = main.replace(/\\W+$/, '').split(/[/@.]/);\n\n  // find state parent\n  var obj = main\n    ? getValue(state, keys)\n    : state;\n  if (!obj) {\n    console.error((\"[Vuex Pathify] Unable to expand wildcard path '\" + path + \"':\\n    - It looks like '\" + (main.replace(/\\W+$/, '')) + \"' does not resolve to an existing state property\"));\n    return []\n  }\n\n  // filter children\n  var rx = new RegExp('^' + last.replace(/\\*/g, '\\\\w+') + '$');\n  return Object\n    .keys(obj)\n    .filter(function (key) { return rx.test(key); })\n    .map(function (key) { return main + key; })\n}\n\n/**\n * Helper function to resolve getters, actions or mutations from a wildcard path\n *\n * Note: this function filters the top-level flat hash of members\n *\n * @param   {string}    path      A path with a wildcard at the end\n * @param   {object}    hash      A hash on which to filter by key => wildcard\n * @returns {string[]}            An array of paths\n */\nfunction resolveHandlers (path, hash) {\n  var rx = new RegExp('^' + path.replace(/\\*/g, '\\\\w+') + '$');\n  return Object.keys(hash).filter(function (key) { return rx.test(key); })\n}\n\n// -------------------------------------------------------------------------------------------------------------------\n// utility\n// -------------------------------------------------------------------------------------------------------------------\n\n/**\n * Pre-flight check for wildcard paths\n *\n * @param   {string}  path\n * @param   {object}  state\n * @returns {boolean}\n */\nfunction init (path, state) {\n  // only wildcards in final path segment are supported\n  if (path.indexOf('*') > -1 && /\\*.*[/@.]/.test(path)) {\n    console.error((\"[Vuex Pathify] Invalid wildcard placement for path '\" + path + \"':\\n    - Wildcards may only be used in the last segment of a path\"));\n    return false\n  }\n\n  // edge case where store sometimes doesn't exist\n  if (!state) {\n    console.error((\"[Vuex Pathify] Unable to expand wildcard path '\" + path + \"':\\n    - The usual reason for this is that the router was set up before the store\\n    - Make sure the store is imported before the router, then reload\"));\n    return false\n  }\n\n  return true\n}\n\n/**\n * Helper function to convert Pathify path syntax paths to objects\n *\n * Handles:\n *\n * - string path\n * - object and array formats\n * - path + object/array format\n * - wildcards in path\n *\n * Returns a single string, or hash of key => paths\n *\n * @param   {string|object|array}  [path]       An optional path prefix\n * @param   {object}                props       An optional hash or array of paths / segments\n * @param   {function}              fnResolver  A function to resolve wildcards\n * @returns {object|string}\n */\nfunction makePaths (path, props, fnResolver) {\n  // handle wildcards\n  if (typeof path === 'string' && path.indexOf('*') > -1) {\n    return makePathsHash(fnResolver(path))\n  }\n\n  // handle array as path\n  if (Array.isArray(path)) {\n    return makePathsHash(path)\n  }\n\n  // handle object as path\n  if (isObject(path)) {\n    props = path;\n    path = '';\n  }\n\n  // if props is an array\n  if (Array.isArray(props)) {\n    var paths = props\n      .map(function (prop) {\n        return makePath(path, prop)\n      });\n    return makePathsHash(paths)\n  }\n\n  // if props is an object\n  if (isObject(props)) {\n    return Object\n      .keys(props)\n      .reduce(function (paths, key) {\n        paths[key] = makePath(path, props[key]);\n        return paths\n      }, {})\n  }\n\n  // if path is a single string without wildcards\n  return path\n}\n\n/**\n * Helper function to concatenate two path components into a valid path\n *\n * Handles one or no \"/\" \"@\" or '.' characters in either string\n *\n * @param   {string}  path\n * @param   {string}  target\n * @returns {string}\n */\nfunction makePath (path, target) {\n  if ( target === void 0 ) target = '';\n\n  path = path.replace(/\\/+$/, '');\n  var value = path.indexOf('@') > -1\n    ? path + '.' + target\n    : path + '/' + target;\n  return value\n    .replace(/^\\/|[.@/]+$/, '')\n    .replace(/\\/@/, '@')\n    .replace(/@\\./, '@')\n}\n\n/**\n * Helper function to convert an array of paths to a hash\n *\n * Uses the last path segment as the key\n *\n * @param   {string[]}  paths   An array of paths to convert to a hash\n * @returns {object}            A hash of paths\n */\nfunction makePathsHash (paths) {\n  return paths.reduce(function (paths, path) {\n    var key = path.match(/\\w+$/);\n    paths[key] = path;\n    return paths\n  }, {})\n}\n\n// -------------------------------------------------------------------------------------------------------------------\n// entry\n// -------------------------------------------------------------------------------------------------------------------\n\nfunction get (path, props, useComputed) {\n  if ( useComputed === void 0 ) useComputed = true;\n\n  if (arguments.length === 2 && props === false) {\n    props = null;\n    useComputed = false;\n  }\n  var store = getStore();\n  return make(path, props, getOne, function (path) {\n    return expandGet(path, store.state, store.getters)\n  }, useComputed)\n}\n\nfunction sync (path, props, useComputed) {\n  if ( useComputed === void 0 ) useComputed = true;\n\n  if (arguments.length === 2 && props === false) {\n    props = null;\n    useComputed = false;\n  }\n  var store = getStore();\n  return make(path, props, syncOne, function (path) {\n    return expandSync(path, store.state)\n  }, useComputed)\n}\n\nfunction call (path, props) {\n  var store = getStore();\n  return make(path, props, callOne, function (path) {\n    return expandCall(path, store._actions)\n  })\n}\n\n// -------------------------------------------------------------------------------------------------------------------\n// utility\n// -------------------------------------------------------------------------------------------------------------------\n\n/**\n * Creates multiple 2-way vue:vuex computed properties\n *\n * The function has multiple usages:\n *\n *  1. multiple properties from multiple modules\n *\n *     - @usage                                 ...sync({foo: 'module1/foo', bar: 'module2/bar'})\n *\n *     - @param   {Object}          props       a hash of key:path state/getter or commit/action references\n *\n *  2. multiple properties from a single module (object shorthand)\n *\n *     - @usage                                 ...sync('module', {foo: 'foo', bar: 'bar'})\n *\n *     - @param   {string}          path        a path to a module\n *     - @param   {Object}          props       a hash of key:prop state/getter or commit/action references\n *\n *  3. multiple properties from a single module (array shorthand)\n *\n *     - @usage                                 ...sync('module', ['foo', 'bar'])\n *\n *     - @param   {string}          path        a path to a module\n *     - @param   {Array}           props       an Array of state/getter or commit/action references\n *\n * Where different getter / setters need to be specified, pass getter and setter in\n * the same string, separating with a | character:\n *\n *     - @usage                                 ...sync('module', ['foo|updateFoo'])\n *\n * @param   {string|Object}         path        a path to a module, or a hash of state/getter or commit/action references\n * @param   {Object|Array}          props       a hash of state/getter or commit/action references\n * @param   {Function}              fnHandler   a callback function to create the handler\n * @param   {Function}              fnResolver\n * @param   {boolean}               useComputed\n * @returns {{set, get}}                        a hash of Objects\n */\nfunction make (path, props, fnHandler, fnResolver, useComputed) {\n  if ( useComputed === void 0 ) useComputed = false;\n\n  // expand path / props\n  var data = makePaths(path, props, fnResolver);\n\n  // handle single paths\n  if (typeof data === 'string') {\n    return useComputed\n      ? computed(fnHandler(data))\n      : fnHandler(data)\n  }\n\n  // handle multiple properties\n  Object\n    .keys(data)\n    .forEach(function (key) {\n      data[key] = useComputed\n        ? computed(fnHandler(data[key]))\n        : fnHandler(data[key]);\n    });\n  return data\n}\n\n// -------------------------------------------------------------------------------------------------------------------\n// one\n// -------------------------------------------------------------------------------------------------------------------\n\n/**\n * Creates a single 2-way vue:vuex computed property\n *\n * @param   {string}      path      a path to a state/getter reference. Path can contain an optional commit / action reference, separated by a |, i.e. foo/bar|updateBar\n * @returns {Object}                a single get/set Object\n */\nfunction syncOne (path) {\n  var ref = path.split('|');\n  var getter = ref[0];\n  var setter = ref[1];\n  if (setter) {\n    setter = getter.replace(/\\w+!?$/, setter.replace('!', '') + '!');\n  }\n  return getter && setter\n    ? { get: getOne(getter, true), set: setOne(setter) }\n    : { get: getOne(getter, true), set: setOne(getter) }\n}\n\n/**\n * Creates a single 1-way vue:vuex computed getter\n *\n * @param   {string}      path          A path to a state/getter reference\n * @param   {boolean}    [stateOnly]    An optional flag to get from state only (used when syncing)\n * @returns {Object}                    A single getter function\n */\nfunction getOne (path, stateOnly) {\n  var getter, store;\n  return function () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    if (!getter || !store) {\n      store = getStore();\n      getter = makeGetter(store, path, stateOnly);\n    }\n    return getter.call.apply(getter, [ this ].concat( args ))\n  }\n}\n\n/**\n * Creates a single 1-way vue:vuex setter\n *\n * @param   {string}      path      a path to an action/commit reference\n * @returns {Function}              a single setter function\n */\nfunction setOne (path) {\n  var setter, store;\n  return function (value) {\n    if (!setter || !store) {\n      store = getStore();\n      setter = makeSetter(store, path);\n    }\n    // this.$nextTick(() => this.$emit('sync', path, value))\n    return setter.call(this, value)\n  }\n}\n\n/**\n * Creates a single action dispatcher\n *\n * @param   {string}      path      a path to an action/commit reference\n * @returns {Function}              a single setter function\n */\nfunction callOne (path) {\n  var store = getStore();\n  return function (value) {\n    return store.dispatch(path, value)\n  }\n}\n\n/**\n * @module\n * @description Decorators for Vuex Pathify component helpers\n *\n * For example:\n * ```js\n * @Component\n * class MyComponent extends Vue {\n *   @Get('name')\n *   @Set('name')\n *   @Call('setName')\n * }\n * ```\n */\n\n/**\n * Decorator for `get` component helper.\n * @param   {string}          path    The path to store property\n * @returns {VueDecorator}            Vue decorator to be used in Vue class component.\n */\nfunction Get (path) {\n  if (typeof path !== 'string' || arguments.length > 1) { throw new Error('Property decorators can only be used for single property access') }\n  return createDecorator(function (options, key) {\n    if (!options.computed) { options.computed = {}; }\n    options.computed[key] = get(path);\n  })\n}\n\n/**\n * Decorator for `sync` component helper.\n * @param   {string}          path    The path to store property\n * @returns {VueDecorator}            Vue decorator to be used in Vue class component.\n */\nfunction Sync (path) {\n  if (typeof path !== 'string' || arguments.length > 1) { throw new Error('Property decorators can only be used for single property access') }\n  return createDecorator(function (options, key) {\n    if (!options.computed) { options.computed = {}; }\n    options.computed[key] = sync(path);\n  })\n}\n\n/**\n * Decorator for `call` component helper.\n * @param   {string}          path    The path to store property\n * @returns {VueDecorator}            Vue decorator to be used in Vue class component.\n */\nfunction Call (path) {\n  if (typeof path !== 'string' || arguments.length > 1) { throw new Error('Property decorators can only be used for single property access') }\n  return createDecorator(function (options, key) {\n    if (!options.methods) { options.methods = {}; }\n    options.methods[key] = call(path);\n  })\n}\n\nexport default pathify;\nexport { store as make, Payload, get, sync, call, Get, Sync, Call, commit, dispatch, registerModule };\n"],
  "mappings": "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",
  "names": ["_getPrototypeOf", "o", "_setPrototypeOf", "p", "call", "get", "VueImpl", "PropsMixin", "options", "options", "obj", "ref", "store", "resolver", "Payload", "commit", "dispatch", "options", "members", "state", "paths", "path"]
}
