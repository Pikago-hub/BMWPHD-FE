import {
  computed,
  proxyRefs,
  ref
} from "./chunk-IC65DETL.js";
import "./chunk-RSJERJUL.js";

// node_modules/vue-class-component/dist/vue-class-component.esm-bundler.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _possibleConstructorReturn(self, call2) {
  if (call2 && (typeof call2 === "object" || typeof call2 === "function")) {
    return call2;
  }
  return _assertThisInitialized(self);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
    return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function defineGetter(obj, key, getter) {
  Object.defineProperty(obj, key, {
    get: getter,
    enumerable: false,
    configurable: true
  });
}
function defineProxy(proxy, key, target) {
  Object.defineProperty(proxy, key, {
    get: function get2() {
      return target[key].value;
    },
    set: function set(value) {
      target[key].value = value;
    },
    enumerable: true,
    configurable: true
  });
}
function getSuper(Ctor) {
  var superProto = Object.getPrototypeOf(Ctor.prototype);
  if (!superProto) {
    return void 0;
  }
  return superProto.constructor;
}
function getOwn(value, key) {
  return value.hasOwnProperty(key) ? value[key] : void 0;
}
var VueImpl = function() {
  function VueImpl2(props, ctx) {
    var _this = this;
    _classCallCheck(this, VueImpl2);
    defineGetter(this, "$props", function() {
      return props;
    });
    defineGetter(this, "$attrs", function() {
      return ctx.attrs;
    });
    defineGetter(this, "$slots", function() {
      return ctx.slots;
    });
    defineGetter(this, "$emit", function() {
      return ctx.emit;
    });
    Object.keys(props).forEach(function(key) {
      Object.defineProperty(_this, key, {
        enumerable: false,
        configurable: true,
        writable: true,
        value: props[key]
      });
    });
  }
  _createClass(VueImpl2, null, [{
    key: "registerHooks",
    value: function registerHooks(keys) {
      var _this$__h;
      (_this$__h = this.__h).push.apply(_this$__h, _toConsumableArray(keys));
    }
  }, {
    key: "with",
    value: function _with(Props) {
      var propsMeta = new Props();
      var props = {};
      Object.keys(propsMeta).forEach(function(key) {
        var meta = propsMeta[key];
        props[key] = meta !== null && meta !== void 0 ? meta : null;
      });
      var PropsMixin = function(_this2) {
        _inherits(PropsMixin2, _this2);
        var _super = _createSuper(PropsMixin2);
        function PropsMixin2() {
          _classCallCheck(this, PropsMixin2);
          return _super.apply(this, arguments);
        }
        return PropsMixin2;
      }(this);
      PropsMixin.__b = {
        props
      };
      return PropsMixin;
    }
  }, {
    key: "__vccOpts",
    get: function get2() {
      if (this === Vue) {
        return {};
      }
      var Ctor = this;
      var cache = getOwn(Ctor, "__c");
      if (cache) {
        return cache;
      }
      var options2 = _objectSpread2({}, getOwn(Ctor, "__o"));
      Ctor.__c = options2;
      var Super = getSuper(Ctor);
      if (Super) {
        options2["extends"] = Super.__vccOpts;
      }
      var base = getOwn(Ctor, "__b");
      if (base) {
        options2.mixins = options2.mixins || [];
        options2.mixins.unshift(base);
      }
      options2.methods = _objectSpread2({}, options2.methods);
      options2.computed = _objectSpread2({}, options2.computed);
      var proto = Ctor.prototype;
      Object.getOwnPropertyNames(proto).forEach(function(key) {
        if (key === "constructor") {
          return;
        }
        if (Ctor.__h.indexOf(key) > -1) {
          options2[key] = proto[key];
          return;
        }
        var descriptor = Object.getOwnPropertyDescriptor(proto, key);
        if (typeof descriptor.value === "function") {
          options2.methods[key] = descriptor.value;
          return;
        }
        if (descriptor.get || descriptor.set) {
          options2.computed[key] = {
            get: descriptor.get,
            set: descriptor.set
          };
          return;
        }
      });
      options2.setup = function(props, ctx) {
        var _promise;
        var data = new Ctor(props, ctx);
        var dataKeys = Object.keys(data);
        var plainData = {};
        var promise = null;
        dataKeys.forEach(function(key) {
          if (data[key] === void 0 || data[key] && data[key].__s) {
            return;
          }
          plainData[key] = ref(data[key]);
          defineProxy(data, key, plainData);
        });
        dataKeys.forEach(function(key) {
          if (data[key] && data[key].__s) {
            var setupState = data[key].__s();
            if (setupState instanceof Promise) {
              if (!promise) {
                promise = Promise.resolve(plainData);
              }
              promise = promise.then(function() {
                return setupState.then(function(value) {
                  plainData[key] = proxyRefs(value);
                  return plainData;
                });
              });
            } else {
              plainData[key] = proxyRefs(setupState);
            }
          }
        });
        return (_promise = promise) !== null && _promise !== void 0 ? _promise : plainData;
      };
      var decorators = getOwn(Ctor, "__d");
      if (decorators) {
        decorators.forEach(function(fn) {
          return fn(options2);
        });
      }
      var injections = ["render", "ssrRender", "__file", "__cssModules", "__scopeId", "__hmrId"];
      injections.forEach(function(key) {
        if (Ctor[key]) {
          options2[key] = Ctor[key];
        }
      });
      return options2;
    }
  }]);
  return VueImpl2;
}();
VueImpl.__h = ["data", "beforeCreate", "created", "beforeMount", "mounted", "beforeUnmount", "unmounted", "beforeUpdate", "updated", "activated", "deactivated", "render", "errorCaptured", "serverPrefetch"];
var Vue = VueImpl;
function createDecorator(factory) {
  return function(target, key, index) {
    var Ctor = typeof target === "function" ? target : target.constructor;
    if (!Ctor.__d) {
      Ctor.__d = [];
    }
    if (typeof index !== "number") {
      index = void 0;
    }
    Ctor.__d.push(function(options2) {
      return factory(options2, key, index);
    });
  };
}

// node_modules/vuex-pathify/dist/vuex-pathify.esm.js
function isPlainObject(value) {
  return isObject(value) && !Array.isArray(value);
}
function isObject(value) {
  return !!value && typeof value === "object";
}
function isNumeric(value) {
  return typeof value === "number" || /^\d+$/.test(value);
}
function hasKey(obj, key) {
  return isObject(obj) && key in obj;
}
function getKeys(value) {
  return !value ? [] : Array.isArray(value) ? value.map(function(key) {
    return String(key);
  }) : typeof value === "object" ? Object.keys(value) : typeof value === "string" ? value.match(/[-$\w]+/g) || [] : [];
}
function getValue(obj, path) {
  var value = obj;
  var keys = getKeys(path);
  keys.every(function(key) {
    var valid = isObject(value) && value.hasOwnProperty(key);
    value = valid ? value[key] : void 0;
    return valid;
  });
  return value;
}
function setValue(obj, path, value, create) {
  if (create === void 0)
    create = false;
  var keys = getKeys(path);
  return keys.reduce(function(obj2, key, index) {
    if (!obj2) {
      return false;
    }
    if (Array.isArray(obj2) && isNumeric(key)) {
      key = parseInt(key);
    }
    if (index === keys.length - 1) {
      obj2[key] = value;
      return true;
    } else if (!isObject(obj2[key]) || !(key in obj2)) {
      if (create) {
        obj2[key] = isNumeric(keys[index + 1]) ? [] : {};
      } else {
        return false;
      }
    }
    return obj2[key];
  }, obj);
}
function hasValue(obj, path) {
  var keys = getKeys(path);
  if (isObject(obj)) {
    while (keys.length) {
      var key = keys.shift();
      if (hasKey(obj, key)) {
        obj = obj[key];
      } else {
        return false;
      }
    }
    return true;
  }
  return false;
}
function clone(obj) {
  return JSON.parse(JSON.stringify(obj));
}
var options = {
  mapping: "standard",
  strict: true,
  cache: true,
  deep: 1
};
var formatters = {
  camel: function() {
    var args = [], len = arguments.length;
    while (len--)
      args[len] = arguments[len];
    return args.shift() + args.map(function(text) {
      return text.replace(/\w/, function(c) {
        return c.toUpperCase();
      });
    }).join("");
  },
  snake: function() {
    var ref2;
    var args = [], len = arguments.length;
    while (len--)
      args[len] = arguments[len];
    return (ref2 = this).camel.apply(ref2, args).replace(/([a-z])([A-Z])/g, function(match, a, b) {
      return a + "_" + b;
    }).toLowerCase();
  },
  const: function() {
    var ref2;
    var args = [], len = arguments.length;
    while (len--)
      args[len] = arguments[len];
    return (ref2 = this).snake.apply(ref2, args).toUpperCase();
  }
};
var members = {
  state: "state",
  getters: "getters",
  actions: "_actions",
  mutations: "_mutations"
};
var resolvers = {
  standard: function standard(type, name, formatters$$1) {
    switch (type) {
      case "mutations":
        return formatters$$1.const("set", name);
      case "actions":
        return formatters$$1.camel("set", name);
    }
    return name;
  },
  simple: function simple(type, name, formatters$$1) {
    if (type === "actions") {
      return formatters$$1.camel("set", name);
    }
    return name;
  }
};
var resolver;
function resolveName(type, name) {
  if (name.match(/!$/)) {
    return name.substr(0, name.length - 1);
  }
  var fn = resolver;
  if (!fn) {
    if (typeof options.mapping === "function") {
      fn = options.mapping;
    } else {
      fn = resolvers[options.mapping];
      if (!fn) {
        throw new Error("[Vuex Pathify] Unknown mapping '" + options.mapping + "' in options\n    - Choose one of '" + Object.keys(resolvers).join("', '") + "'\n    - Or, supply a custom function\n");
      }
    }
    resolver = fn;
  }
  return resolver(type, name, formatters);
}
function resolve(store2, path) {
  var absPath = path.replace(/[/@!]+/g, ".");
  var ref2 = path.split("@");
  var statePath = ref2[0];
  var objPath = ref2[1];
  var modPath, trgName;
  if (statePath.indexOf("/") > -1) {
    var keys = statePath.split("/");
    trgName = keys.pop();
    modPath = keys.join("/");
  } else {
    trgName = statePath;
  }
  if (modPath && !store2._modulesNamespaceMap[modPath + "/"]) {
    throw new Error("[Vuex Pathify] Unknown module '" + modPath + "' via path '" + path + "'");
  }
  return {
    absPath,
    module: modPath,
    target: statePath,
    name: trgName.replace("!", ""),
    isDynamic: path.indexOf(":") > -1,
    get: function(type) {
      var member = store2[members[type]];
      var resName = resolveName(type, trgName);
      var trgPath = modPath ? modPath + "/" + resName : resName;
      return {
        exists: type === "state" ? hasValue(member, trgPath) : member ? trgPath in member : false,
        member,
        trgPath,
        trgName: resName,
        objPath
      };
    }
  };
}
function getError(path, resolver2, aName, a, bName, b) {
  var error = "[Vuex Pathify] Unable to map path '" + path + "':";
  if (path.indexOf("!") > -1) {
    error += "\n    - Did not find " + aName + " or " + bName + " named '" + resolver2.name + "' on " + (resolver2.module ? "module '" + resolver2.module + "'" : "root store");
  } else {
    var aText = a ? aName + " '" + a.trgName + "' or " : "";
    var bText = bName + " '" + b.trgName + "'";
    error += "\n    - Did not find " + aText + bText + " on " + (resolver2.module ? "module '" + resolver2.module + "'" : "store") + "\n    - Use direct syntax '" + resolver2.target.replace(/(@|$)/, "!$1") + "' (if member exists) to target directly";
  }
  return error;
}
var Payload = function Payload2(expr, path, value) {
  this.expr = expr;
  this.path = path;
  this.value = value;
};
Payload.prototype.update = function update(target) {
  if (!options.deep) {
    console.error("[Vuex Pathify] Unable to access sub-property for path '" + this.expr + "':\n    - Set option 'deep' to 1 to allow it");
    return target;
  }
  var success = setValue(target, this.path, this.value, options.deep > 1);
  if (!success && true) {
    console.error("[Vuex Pathify] Unable to create sub-property for path '" + this.expr + "':\n    - Set option 'deep' to 2 to allow it");
    return target;
  }
  return Array.isArray(target) ? [].concat(target) : Object.assign({}, target);
};
Payload.isSerialized = function(value) {
  return isPlainObject(value) && "expr" in value && "path" in value && "value" in value;
};
function makeSetter(store2, path) {
  var resolver2 = resolve(store2, path);
  var action = resolver2.get("actions");
  if (action.exists) {
    return function(value) {
      var payload = action.objPath ? new Payload(path, action.objPath, value) : value;
      return store2.dispatch(action.trgPath, payload);
    };
  }
  var mutation = resolver2.get("mutations");
  if (mutation.exists || resolver2.isDynamic) {
    return function(value) {
      if (resolver2.isDynamic) {
        var interpolated = interpolate(path, this);
        mutation = resolve(store2, interpolated).get("mutations");
      }
      var payload = mutation.objPath ? new Payload(path, mutation.objPath, value) : value;
      return store2.commit(mutation.trgPath, payload);
    };
  }
  if (true) {
    console.error(getError(path, resolver2, "action", action, "mutation", mutation));
  }
  return function(value) {
  };
}
function makeGetter(store2, path, stateOnly) {
  var resolver2 = resolve(store2, path);
  var getter;
  if (!stateOnly) {
    getter = resolver2.get("getters");
    if (getter.exists) {
      return function() {
        var value = getter.member[getter.trgPath];
        return getter.objPath ? getValueIfEnabled(path, value, getter.objPath) : value;
      };
    }
  }
  var state = resolver2.get("state");
  if (state.exists || resolver2.isDynamic) {
    return function() {
      var absPath = resolver2.isDynamic ? interpolate(resolver2.absPath, this) : resolver2.absPath;
      return getValueIfEnabled(path, store2.state, absPath);
    };
  }
  if (true) {
    console.error(getError(path, resolver2, "getter", getter, "state", state));
  }
  return function() {
  };
}
function getValueIfEnabled(expr, source, path) {
  if (!options.deep && expr.indexOf("@") > -1) {
    console.error("[Vuex Pathify] Unable to access sub-property for path '" + expr + "':\n    - Set option 'deep' to 1 to allow it");
    return;
  }
  return getValue(source, path);
}
function interpolate(path, scope) {
  return path.replace(/:(\w+)/g, function replace(all, token) {
    if (!(token in scope)) {
      console.error('Error resolving dynamic store path: The property "' + token + '" does not exist on the scope', scope);
    }
    return scope[token];
  });
}
var vuex = {
  store: {
    state: null,
    commit: function commit() {
      if (true) {
        console.error("[Vuex Pathify] Plugin not initialized!");
      }
    },
    dispatch: function dispatch() {
      if (true) {
        console.error("[Vuex Pathify] Plugin not initialized!");
      }
    }
  }
};
function getStore() {
  return vuex.store;
}
function setStore(store2) {
  vuex.store = store2;
  store2.set = function(path, value) {
    var setter = makeSetter(store2, path);
    if (typeof setter !== "undefined") {
      return setter(value);
    }
  };
  store2.get = function(path) {
    var args = [], len = arguments.length - 1;
    while (len-- > 0)
      args[len] = arguments[len + 1];
    var getter = makeGetter(store2, path);
    if (typeof getter !== "undefined") {
      var value = getter();
      return typeof value === "function" ? value.apply(void 0, args) : value;
    }
  };
  store2.copy = function(path) {
    var args = [], len = arguments.length - 1;
    while (len-- > 0)
      args[len] = arguments[len + 1];
    var value = store2.get.apply(store2, [path].concat(args));
    return isObject(value) ? clone(value) : value;
  };
}
function commit2() {
  var ref2;
  var args = [], len = arguments.length;
  while (len--)
    args[len] = arguments[len];
  (ref2 = vuex.store).commit.apply(ref2, args);
}
function dispatch2() {
  var ref2;
  var args = [], len = arguments.length;
  while (len--)
    args[len] = arguments[len];
  return (ref2 = vuex.store).dispatch.apply(ref2, args);
}
function registerModule(path, module, callback, options2) {
  return {
    beforeCreate: function beforeCreate() {
      this.$store.registerModule(path, module, options2);
      var members2 = callback();
      this.$options.computed = Object.assign(this.$options.computed || {}, members2.computed || {});
      this.$options.methods = Object.assign(this.$options.methods || {}, members2.methods || {});
    },
    destroyed: function destroyed() {
      this.$store.unregisterModule(path);
    }
  };
}
function resolve$1(type) {
  return resolveName(type, "value");
}
function debug() {
  console.log("\n  [Vuex Pathify] Options:\n\n  Mapping (" + (typeof options.mapping === "function" ? "custom" : options.mapping) + ")\n-------------------------------\n  path       : value\n  state      : " + resolve$1("state") + "\n  getters    : " + resolve$1("getters") + "\n  actions    : " + resolve$1("actions") + "\n  mutations  : " + resolve$1("mutations") + "\n\n  Settings\n-------------------------------\n  strict     : " + options.strict + "\n  cache      : " + options.cache + "\n  deep       : " + options.deep + "\n\n");
}
function plugin(store2) {
  setStore(store2);
}
var pathify = {
  options,
  plugin,
  debug
};
function getStateKeys(state) {
  return getKeys(typeof state === "function" ? state() : state);
}
function makeGetters(state) {
  return getStateKeys(state).reduce(function(obj, key) {
    var getter = resolveName("getters", key);
    obj[getter] = function(state2) {
      return state2[key];
    };
    return obj;
  }, {});
}
function makeMutations(state) {
  return getStateKeys(state).reduce(function(obj, key) {
    var mutation = resolveName("mutations", key);
    obj[mutation] = function(state2, value) {
      if (value instanceof Payload) {
        value = value.update(state2[key]);
      } else if (Payload.isSerialized(value)) {
        value = Payload.prototype.update.call(value, state2[key]);
      }
      state2[key] = value;
    };
    return obj;
  }, {});
}
function makeActions(state) {
  return getStateKeys(state).reduce(function(obj, key) {
    var action = resolveName("actions", key);
    var mutation = resolveName("mutations", key);
    obj[action] = function(ref2, value) {
      var commit3 = ref2.commit;
      commit3(mutation, value);
    };
    return obj;
  }, {});
}
var store = {
  getters: makeGetters,
  mutations: makeMutations,
  actions: makeActions
};
function expandGet(path, state, getters) {
  if (!init(path, state)) {
    return "";
  }
  return resolveStates(path, state).concat(resolveHandlers(path, getters));
}
function expandSync(path, state) {
  if (!init(path, state)) {
    return "";
  }
  return resolveStates(path, state);
}
function expandCall(path, actions) {
  if (!init(path, actions)) {
    return "";
  }
  return resolveHandlers(path, actions);
}
function resolveStates(path, state) {
  var last = path.match(/([^/@\.]+)$/)[1];
  var main = path.substring(0, path.length - last.length);
  var keys = main.replace(/\W+$/, "").split(/[/@.]/);
  var obj = main ? getValue(state, keys) : state;
  if (!obj) {
    console.error("[Vuex Pathify] Unable to expand wildcard path '" + path + "':\n    - It looks like '" + main.replace(/\W+$/, "") + "' does not resolve to an existing state property");
    return [];
  }
  var rx = new RegExp("^" + last.replace(/\*/g, "\\w+") + "$");
  return Object.keys(obj).filter(function(key) {
    return rx.test(key);
  }).map(function(key) {
    return main + key;
  });
}
function resolveHandlers(path, hash) {
  var rx = new RegExp("^" + path.replace(/\*/g, "\\w+") + "$");
  return Object.keys(hash).filter(function(key) {
    return rx.test(key);
  });
}
function init(path, state) {
  if (path.indexOf("*") > -1 && /\*.*[/@.]/.test(path)) {
    console.error("[Vuex Pathify] Invalid wildcard placement for path '" + path + "':\n    - Wildcards may only be used in the last segment of a path");
    return false;
  }
  if (!state) {
    console.error("[Vuex Pathify] Unable to expand wildcard path '" + path + "':\n    - The usual reason for this is that the router was set up before the store\n    - Make sure the store is imported before the router, then reload");
    return false;
  }
  return true;
}
function makePaths(path, props, fnResolver) {
  if (typeof path === "string" && path.indexOf("*") > -1) {
    return makePathsHash(fnResolver(path));
  }
  if (Array.isArray(path)) {
    return makePathsHash(path);
  }
  if (isObject(path)) {
    props = path;
    path = "";
  }
  if (Array.isArray(props)) {
    var paths = props.map(function(prop) {
      return makePath(path, prop);
    });
    return makePathsHash(paths);
  }
  if (isObject(props)) {
    return Object.keys(props).reduce(function(paths2, key) {
      paths2[key] = makePath(path, props[key]);
      return paths2;
    }, {});
  }
  return path;
}
function makePath(path, target) {
  if (target === void 0)
    target = "";
  path = path.replace(/\/+$/, "");
  var value = path.indexOf("@") > -1 ? path + "." + target : path + "/" + target;
  return value.replace(/^\/|[.@/]+$/, "").replace(/\/@/, "@").replace(/@\./, "@");
}
function makePathsHash(paths) {
  return paths.reduce(function(paths2, path) {
    var key = path.match(/\w+$/);
    paths2[key] = path;
    return paths2;
  }, {});
}
function get(path, props, useComputed) {
  if (useComputed === void 0)
    useComputed = true;
  if (arguments.length === 2 && props === false) {
    props = null;
    useComputed = false;
  }
  var store2 = getStore();
  return make(path, props, getOne, function(path2) {
    return expandGet(path2, store2.state, store2.getters);
  }, useComputed);
}
function sync(path, props, useComputed) {
  if (useComputed === void 0)
    useComputed = true;
  if (arguments.length === 2 && props === false) {
    props = null;
    useComputed = false;
  }
  var store2 = getStore();
  return make(path, props, syncOne, function(path2) {
    return expandSync(path2, store2.state);
  }, useComputed);
}
function call(path, props) {
  var store2 = getStore();
  return make(path, props, callOne, function(path2) {
    return expandCall(path2, store2._actions);
  });
}
function make(path, props, fnHandler, fnResolver, useComputed) {
  if (useComputed === void 0)
    useComputed = false;
  var data = makePaths(path, props, fnResolver);
  if (typeof data === "string") {
    return useComputed ? computed(fnHandler(data)) : fnHandler(data);
  }
  Object.keys(data).forEach(function(key) {
    data[key] = useComputed ? computed(fnHandler(data[key])) : fnHandler(data[key]);
  });
  return data;
}
function syncOne(path) {
  var ref2 = path.split("|");
  var getter = ref2[0];
  var setter = ref2[1];
  if (setter) {
    setter = getter.replace(/\w+!?$/, setter.replace("!", "") + "!");
  }
  return getter && setter ? { get: getOne(getter, true), set: setOne(setter) } : { get: getOne(getter, true), set: setOne(getter) };
}
function getOne(path, stateOnly) {
  var getter, store2;
  return function() {
    var args = [], len = arguments.length;
    while (len--)
      args[len] = arguments[len];
    if (!getter || !store2) {
      store2 = getStore();
      getter = makeGetter(store2, path, stateOnly);
    }
    return getter.call.apply(getter, [this].concat(args));
  };
}
function setOne(path) {
  var setter, store2;
  return function(value) {
    if (!setter || !store2) {
      store2 = getStore();
      setter = makeSetter(store2, path);
    }
    return setter.call(this, value);
  };
}
function callOne(path) {
  var store2 = getStore();
  return function(value) {
    return store2.dispatch(path, value);
  };
}
function Get(path) {
  if (typeof path !== "string" || arguments.length > 1) {
    throw new Error("Property decorators can only be used for single property access");
  }
  return createDecorator(function(options2, key) {
    if (!options2.computed) {
      options2.computed = {};
    }
    options2.computed[key] = get(path);
  });
}
function Sync(path) {
  if (typeof path !== "string" || arguments.length > 1) {
    throw new Error("Property decorators can only be used for single property access");
  }
  return createDecorator(function(options2, key) {
    if (!options2.computed) {
      options2.computed = {};
    }
    options2.computed[key] = sync(path);
  });
}
function Call(path) {
  if (typeof path !== "string" || arguments.length > 1) {
    throw new Error("Property decorators can only be used for single property access");
  }
  return createDecorator(function(options2, key) {
    if (!options2.methods) {
      options2.methods = {};
    }
    options2.methods[key] = call(path);
  });
}
var vuex_pathify_esm_default = pathify;
export {
  Call,
  Get,
  Payload,
  Sync,
  call,
  commit2 as commit,
  vuex_pathify_esm_default as default,
  dispatch2 as dispatch,
  get,
  store as make,
  registerModule,
  sync
};
/**
  * vue-class-component v8.0.0-rc.1
  * (c) 2015-present Evan You
  * @license MIT
  */
//# sourceMappingURL=vuex-pathify.js.map
